---
title: EVOScore-2 商用友好的致病性预测数据集
tags: coding
---

在错义突变范畴，SOTA 是 AlphaMissense 没有错，也建议大家尽可能的去用 AlphaMissense。但对于需要合规商业化来说，AlphaMissense 是不可用的（CC BY-NC-SA 协议）。

因此，必须有一个替代方案：使用 **[ESM-2](https://huggingface.co/facebook/esm2_t36_3B_UR50D)**。

*注：虽然 ESM-3 模型已经发布，但其免费版严禁商用，且仅开源了小参数模型。相比之下，Meta 发布的 ESM-2 采用 MIT 协议，是目前唯一兼具高性能与商业合规性的蛋白质语言模型。*

**[EVOScore-2](https://huggingface.co/datasets/pzweuj/EVOScore-2)** 数据集采用MIT许可开源，意味着你可以不受限制的接入自己的商业流程中。



### 1. 基础资料

我本来已经想着用自行部署`esm2_t33_650M_UR50D`来对所有位点进行重新计算，但发现[ntranoslab/vesm_scores](https://huggingface.co/datasets/ntranoslab/vesm_scores)已经使用了`esm2_t36_3B_UR50D`来完成了这个工作。

这样一来，结果的精度比我原本构想中的精度更高，也节省了大量的工作时间，感谢[ntranoslab](https://huggingface.co/ntranoslab)。

对应的`VESM_3B`数据集是以`MIT`开源分发的，放心使用。



### 2. 生成标准 VCF

现在我们需要做的是把`hg38_VESM_3B_scores.parquet.gzip`转换成Vcf格式，这样即可直接对接到VEP流程中。

```bash
python -c "import pandas as pd; print(pd.read_parquet('hg38_VESM_3B_scores.parquet.gzip').head())"
```

通过查看parquet文件，可以明确包含的列是这样的

| CHROM | POS   | REF  | ALT  | gnome | uniprot_id | transcript_id     | protein_variant | VESM (3B) |
| ----- | ----- | ---- | ---- | ----- | ---------- | ----------------- | --------------- | --------- |
| chr1  | 69094 | G    | T    | hg38  | Q8NH21     | ENST00000335137.4 | V2L             | -5.5739   |


这样明确我们可以完美的转换到Vcf格式中。



### 3. 验证与基准测试

拿到分数只是第一步。为了给临床提供可信的证据，我们需要建立严格的阈值标准，我们将采用 **“小样本校准，大样本盲测”** 的反向验证策略。我使用[ClinVar的20260126版本](https://ftp.ncbi.nlm.nih.gov/pub/clinvar/vcf_GRCh38/)进行验证。

#### 3.1 清洗 ClinVar 数据

从 NCBI 下载最新的 ClinVar VCF，并进行严格过滤。

**过滤标准（金标准）：**

1. **Variation Type:** 仅保留 `SNV` (Single Nucleotide Variant)。
2. **Consequence:** 仅保留 `Missense` (错义突变)。
3. **Review Status:** 必须有星级 (`CLNSIGCONF` != null 或 星级 >= 1)。
4. **Clinical Significance:**
* **Positive Set (致病):** `Pathogenic` 或 `Likely_pathogenic`。
* **Negative Set (良性):** `Benign` 或 `Likely_benign`。
* *剔除：Conflict, VUS, Drug response 等模糊数据。*

清洗结果如下：

| Input             | 4280453 |
| ----------------- | ------- |
| Output            | 1263960 |
| Pathogenic        | 69598   |
| Likely_pathogenic | 65563   |
| Benign            | 173420  |
| Likely_benign     | 955379  |




#### 3.2 数据集切分—— *核心步骤*

为了避免“既当裁判又当运动员”，**不使用全量数据**来寻找阈值。

我们采用分层抽样，将清洗后的 ClinVar 数据划分为两部分：

* **校准集 (Calibration Set, 20%):** 仅用于寻找最佳 Cutoff 值。
* **验证集 (Benchmark Set, 80%):** 作为“盲盒”，用于最终评估模型性能。

|                   | 校准集 | 验证集 |
| ----------------- | ------ | ------ |
| Pathogenic        | 3111   | 12051  |
| Likely_pathogenic | 5589   | 22748  |
| Benign            | 5442   | 21654  |
| Likely_benign     | 18467  | 73985  |



#### 3.3 确定阈值

**注意：本步骤仅在 20% 的校准集上进行。**

我们将 ESM-2 分数与校准集的标签对齐，根据 ACMG 的证据强度需求确定 Cutoff：

* **PP3 (Supporting/Moderate) 阈值:**
* 寻找 Youden Index 最大点（敏感性与特异性的最佳平衡点）。


* **PP3_Strong (High Specificity) 阈值:**
* 锁定 **Specificity > 95%** 的分数值。
* *逻辑：* 只有当误报率低于 5% 时，我们才敢给出强致病证据。



使用校准集，我们获得了两个阈值

| P_threshold     | -11.5678    |
| --------------- | ----------- |
| **B_threshold** | **-8.4456** |

便于记忆，人为的将EVOScore ＜ -11.6时，认为位点是Pathogenic；而当EVOScore ＞ -8.5时，认为位点是Benign。




#### 3.4 盲测与评估

**本步骤在 80% 的验证集上进行。**

将 3.3 中锁定的阈值，直接应用到这 80% 从未见过的数据上，计算最终指标。

* **鲁棒性验证：** 检查在验证集上，是否依然能维持 >90-95% 的特异性？如果能，说明阈值极其稳健。
* **计算 AUC:** 计算验证集的 ROC 曲线下面积。ESM-2  预期 AUC 应在 **0.85 - 0.90** 之间。

| Predicted P | 20377 | PPV: 0.9547 |
| ----------- | ----- | ----------- |
| Predicted B | 92912 | NPV: 0.9487 |
| Ambiguous         | 17149 | //          |

测试获得`AUC: 0.9575`。单从数值上看，当前阈值展示了优秀的B、P区分能力，存在约13%样本落入不确定区间的问题。从结果看，Ambiguous中存在的实际Pathogenic更多，成功区分出Pathogenic的比例是58.56%(20377/(12051+22748))。

当前的阈值下，EVOScore ＜ -11.6时，我们预期有 95% 的概率是真致病；而当EVOScore ＞ -8.5时，我们预期有 95% 的概率是真良性。而 -8.5 ≤ EVOScore ≤ -11.6的区间里，我们决定**放弃预测这一部分**，将其标记为 **Ambiguous**。




### 4. 总结与应用

通过以上步骤，我们就在完全合规（MIT License）的前提下，拥有了一个性能逼近 AlphaMissense 的数据库 **EVOScore-2**。上述流程[所有代码](https://github.com/SchemaBio/EVOScore-2)以MIT开源。

已转换好的结果，可以在[huggingface](https://huggingface.co/datasets/pzweuj/EVOScore-2)获取。



#### 在VEP中使用

作为custom注释即可

```bash
# 确保EVOScore VCF有索引
tabix -p vcf evoscore.vcf.gz

vep -i input.vcf \
      -o output_annotated.vcf \
      --cache \
      --dir_cache /path/to/vep_cache \
      --offline \
      --custom /path/to/evoscore.vcf.gz,EVOScore,exact,Float,EVOScore
```
